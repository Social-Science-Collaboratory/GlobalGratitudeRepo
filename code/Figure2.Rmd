---
title: "Figure 2: Variability Decomposition"
author: "Nicholas A. Coles, Annabel V. Dang"
description: "Visualizes effect sizes, generating Figure 2 for the manuscript"
output: html_document
editor_options: 
  chunk_output_type: console
---
# Load packages
```{r}
# Load packages
source("setup.R")
```

# Prep data
```{r}
# Open data
df <-
  read.csv(file = here(
    "data/output",
    "unique_country_effect_sizes.csv"
  )) %>%
  select(country:ss_var)

# List of effect size columns and variance columns
effect_size_columns <- c(
  "pa_effect_size", "na_effect_size",
  "optimistic_effect_size", "ls_effect_size",
  "envy_effect_size", "indebted_effect_size"
)

variance_columns <- c(
  "pa_var", "na_var", "optimistic_var",
  "ls_var", "envy_var", "indebted_var"
)

# Estimate total heterogeneity
m <- lapply(1:length(effect_size_columns), function(i) {
  rma.mv(
    yi = df[[effect_size_columns[i]]],
    V = df[[variance_columns[i]]],
    data = df
  )
})

m.c <- lapply(1:length(effect_size_columns), function(i) {
  rma.mv(
    yi = df[[effect_size_columns[i]]],
    V = df[[variance_columns[i]]],
    random = ~ 1 | country,
    data = df
  )
})


m.i <- lapply(1:length(effect_size_columns), function(i) {
  rma.mv(
    yi = df[[effect_size_columns[i]]],
    V = df[[variance_columns[i]]],
    random = ~ 1 | intervention_condition,
    data = df
  )
})

# Fit models for each pair of effect size and variance
m.ic <- lapply(1:length(effect_size_columns), function(i) {
  rma.mv(
    yi = df[[effect_size_columns[i]]],
    V = df[[variance_columns[i]]],
    random = list(~ 1 | intervention_condition, ~ 1 | country),
    data = df
  )
})

# Store the results
names(m.ic) <- paste(effect_size_columns)
```

# Calculate country-level and intervention-level descriptives
```{r}
# Calculate country-level descriptives
d.c <- lapply(effect_size_columns, function(effect_size) {
  d.c <- df %>%
    group_by(country) %>%
    summarise(m = mean(.data[[effect_size]]), .groups = "drop") %>%
    # add [jittered] y-value
    mutate(
      y = 0,
      y = jitter(y, .1)
    ) %>%
    # labels most extreme observations
    mutate(
      label = if_else(m == min(m),
        true = country,
        false = ""
      ),
      label = if_else(m == max(m),
        true = country,
        false = label
      )
    ) %>%
    # include effect size namece
    mutate(effect_size = effect_size)

  return(d.c)
})

# Calculate intervention-level descriptives
d.i <- lapply(effect_size_columns, function(effect_size) {
  d.i <- df %>%
    group_by(intervention_condition) %>%
    summarise(m = mean(.data[[effect_size]]), .groups = "drop") %>%
    # add [jittered] y-value
    mutate(
      y = -0.03,
      y = jitter(y, .1)
    ) %>%
    # labels most extreme observations
    mutate(
      label = if_else(m == min(m),
        true = intervention_condition,
        false = ""
      ),
      label = if_else(m == max(m),
        true = intervention_condition,
        false = label
      )
    ) %>%
    # include effect size name
    mutate(effect_size = effect_size)

  return(d.i)
})

# Calculate total descriptives
d.all <- lapply(effect_size_columns, function(effect_size) {
  df %>%
    group_by(country, intervention_condition) %>%
    summarise(m = mean(.data[[effect_size]]), .groups = "drop") %>%
    mutate(
      effect_size = effect_size,
      y = -0.01 + runif(n(), min = -0.01, max = 0),
      # label extreme values
      label = if_else(m == min(m),
        paste(country, intervention_condition, sep = ", "),
        ""
      ),
      label = if_else(m == max(m),
        paste(country, intervention_condition, sep = ", "),
        label
      )
    ) %>%
    ungroup()
})



# Bind rows
d.c <- bind_rows(d.c)
d.i <- bind_rows(d.i)
d.all <- bind_rows(d.all)
```

#Add Tau
```{r}
# Extract tau values
tau_c <- sapply(m.ic, function(model) sqrt((model$sigma2[2])))
tau_i <- sapply(m.ic, function(model) sqrt((model$sigma2[1])))

# Create data frame
tau_df <- data.frame(
  effect_size = effect_size_columns,
  tau_c = tau_c,
  tau_i = tau_i,
  tau_ci = tau_c / tau_i
)
```

# Create density plots
```{r}
# Create a list of ggplot objects
m.d <- lapply(seq_along(effect_size_columns), function(i) {
  effect_size <- effect_size_columns[i]
  model <- m.ic[[i]]

  # create the plot for each effect size
  plot <- ggplot() +

    # overall effect size estimate
    geom_point(
      aes(
        x = model$b[1],
        y = 5.7
      ),
      shape = 18,
      size = 4,
      color = "grey30"
    ) +

    # 95% CI of overall effect size estimate
    geom_segment(
      aes(
        x = model$ci.lb,
        xend = model$ci.ub,
        y = 5.7,
        yend = 5.7
      ),
      color = "grey30"
    ) +

    # visual indicator: null effect
    geom_segment(aes(x = 0, xend = 0, y = 0, yend = 7),
      color = "grey30", linetype = "dotted"
    ) +

    # density plot: intervention-level heterogeneity
    stat_function(
      fun = dnorm,
      args = list(
        mean = model$b[1],
        sd = sqrt(model$sigma2[1])
      ),
      color = "#E64B35"
    ) +

    # density plot: country-level heterogeneity
    stat_function(
      fun = dnorm,
      args = list(
        mean = model$b[1],
        sd = sqrt(model$sigma2[2])
      ),
      color = "#3C5488"
    )

  # final formatting
  plot <- plot +
    scale_x_continuous(limits = c(-1.25, 1.35)) +
    scale_y_continuous(limits = c(0, 13)) +
    theme_void()

  return(plot)
})

m.d
```

# Plot descriptives
```{r}
# Combine datasets
d.c$dataset <- "d.c"
d.i$dataset <- "d.i"
d.c$intervention_condition <- NA
d.i$country <- NA
d.all$dataset <- "d.all"

d.c.i <- rbind(d.c, d.i, d.all)

# Create a list
m.p <- lapply(effect_size_columns, function(es) {
  data_subset <- subset(d.c.i, effect_size == es)

  ggplot(data_subset) +
    geom_vline(
      xintercept = 0,
      color = "grey30",
      linetype = "dotted"
    ) +

    # add country-level descriptives
    geom_point(
      data = subset(data_subset, dataset == "d.c"),
      aes(x = m, y = y),
      color = "#3C5488", alpha = .5
    ) +

    # add labels for country-level
    geom_text_repel(
      data = subset(data_subset, dataset == "d.c"),
      aes(x = m, y = y, label = label),
      color = "#3C5488", alpha = .5, nudge_y = .005, size = 3
    ) +

    # add overall descriptives
    geom_point(
      data = subset(data_subset, dataset == "d.all"),
      aes(x = m, y = y),
      color = "#A47DAB", alpha = .5
    ) +

    # add labels for overall-level
    geom_text_repel(
      data = subset(data_subset, dataset == "d.all"),
      aes(x = m, y = y, label = label),
      color = "#A47DAB", alpha = .6, nudge_y = .005, size = 3
    ) +

    # add intervention-level descriptives
    geom_point(
      data = subset(data_subset, dataset == "d.i"),
      aes(x = m, y = y),
      color = "#E64B35", alpha = .6
    ) +

    # add labels for intervention-level
    geom_text_repel(
      data = subset(data_subset, dataset == "d.i"),
      aes(x = m, y = y, label = label),
      color = "#E64B35", alpha = .5, nudge_y = .005, size = 3
    ) +

    # aesthetics
    theme_classic() +
    theme(
      axis.title.y = element_blank(),
      axis.title.x = element_blank(),
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    ) +
    scale_x_continuous(limits = c(-1.25, 1.35))
})

m.p
```

#Pooled effect sizes + CI
```{r}
# Effect size estimates + CI + p-value
results_df <- do.call(rbind, lapply(names(m.ic), function(name) {
  model <- m.ic[[name]]

  # extract estimate (Cohen's d or intercept)
  est <- as.numeric(coef(model))

  # standard error
  se <- sqrt(diag(vcov(model)))[1]

  # 95% confidence interval
  ci_lower <- est - 1.96 * se
  ci_upper <- est + 1.96 * se

  # two-sided p-value (Wald test)
  z_value <- est / se
  p_value <- 2 * (1 - pnorm(abs(z_value)))

  # return as data frame
  data.frame(
    outcome = name,
    estimate = round(est, 2),
    ci_lower = round(ci_lower, 2),
    ci_upper = round(ci_upper, 2),
    p_value = p_value
  )
}))

# Create titles
outcome <- c(
  "Positive Affect",
  "Negative Affect",
  "Optimism",
  "Life satisfaction",
  "Envy",
  "Indebtedness"
)

# Replace the outcome column in results_df
results_df$outcome <- outcome
```
```{r}
# Save data frame
write.csv(results_df,
  file = here(
    "data/output",
    "pooled_effect_size.csv"
  )
)
```

# Combine plots
```{r}
# Combine m.d and m.p
combined_plots <- mapply(function(plot_d, plot_p) {
  plot_grid(plot_d, plot_p, ncol = 1, rel_heights = c(.5, 1))
}, m.d, m.p, SIMPLIFY = FALSE)

# Create tau labels
tau_labels <- sapply(tau_df$tau_ci, function(x) {
  if (x > 50) "n.s." else paste0("= ", round(x, 2))
})

# Create the titles
combined_plots <- lapply(1:length(combined_plots), function(i) {
  res <- results_df[i, ]

  combined_plots[[i]] +
    ggtitle(
      paste0(
        letters[i], ". ", res$outcome,
        " (", "<i>d</i> = ", sprintf("%.2f", res$estimate),
        ", 95% CI [", sprintf("%.2f", res$ci_lower), ", ", sprintf("%.2f", res$ci_upper), "])"
      )
    ) +
    theme(
      plot.title = element_markdown(hjust = 0, vjust = 1.5, size = 9, face = "bold")
    )
})

# Build the grid
grid <- plot_grid(
  plotlist = combined_plots,
  ncol = 2
)


# Draw final figure with Cohen's d and tau annotations
ggdraw() +
  draw_plot(grid, 0, 0.05, 1, 0.95) +

  # Cohen's d label at bottom
  draw_label(expression("Cohen's " * italic(d)),
    x = 0.5, y = 0, vjust = -1, size = 10
  ) +

  # Tau numeric labels (positioned per panel, after the title)
  draw_label(tau_labels[1], x = 0.08, y = .94, hjust = 0, size = 9) +
  draw_label(tau_labels[2], x = 0.58, y = .94, hjust = 0, size = 9) +
  draw_label(tau_labels[3], x = 0.08, y = 0.62, hjust = 0, size = 9) +
  draw_label(tau_labels[4], x = 0.58, y = 0.62, hjust = 0, size = 9) +
  draw_label(tau_labels[5], x = 0.08, y = 0.30, hjust = 0, size = 9) +
  draw_label(tau_labels[6], x = 0.58, y = 0.30, hjust = 0, size = 9) +

  # τ headers for first plot
  draw_label(expression(tau[country]),
    x = 0.07, y = 0.96,
    hjust = 1, vjust = 1, color = "#3C5488", size = 9.5
  ) +
  draw_label(expression(tau[practice]),
    x = 0.07, y = 0.938,
    hjust = 1, vjust = 1, color = "#E64B35", size = 9.5
  ) +

  # Horizontal line under tau headers
  draw_line(
    x = c(0.02, 0.075), y = c(.94, .94),
    color = "black", size = 0.5
  )
```

#Extract heterogeneity stats
```{r}
# Calculate Q, I2, p-value
extract_heterogeneity <- function(name, model) {
  Q <- model$QE
  df <- model$k - model$p
  p <- model$QEp

  # compute I²
  I2 <- if (Q <= df) 0 else ((Q - df) / Q) * 100

  data.frame(
    outcome = name,
    Q = round(Q, 2),
    df = df,
    p = round(p, 3),
    I2 = round(I2, 1)
  )
}

# Apply across all models in m.ic
heterogeneity_df <- bind_rows(
  lapply(names(m.ic), function(name) extract_heterogeneity(name, m.ic[[name]]))
)
```
```{r}
# Save data frame
write.csv(heterogeneity_df,
  file = here(
    "data/output",
    "overall_heterogeneity.csv"
  )
)
```

#Prediction Intervals
```{r}
# Calculate practice-level prediction intervals
practice_pred_df <- do.call(rbind, lapply(seq_along(m.i), function(i) {
  mod <- m.i[[i]]

  pred_practice <- predict(mod, digits = 3)

  data.frame(
    effect_size = effect_size_columns[i],
    practice_pred = pred_practice$pred,
    practice_se = pred_practice$se,
    practice_pi_lb = pred_practice$pi.lb,
    practice_pi_ub = pred_practice$pi.ub
  )
}))

# Calculate country-level prediction intervals
country_pred_df <- do.call(rbind, lapply(seq_along(m.i), function(i) {
  mod <- m.c[[i]]

  pred_country <- predict(mod, digits = 3)

  data.frame(
    effect_size = effect_size_columns[i],
    country_pred = pred_country$pred,
    country_se = pred_country$se,
    country_pi_lb = pred_country$pi.lb,
    country_pi_ub = pred_country$pi.ub
  )
}))

pred_df <- left_join(practice_pred_df, country_pred_df, by = "effect_size")
```
```{r}
# Save data frame
write.csv(pred_df,
  file = here(
    "data/output",
    "prediction_intervals.csv"
  )
)
```

